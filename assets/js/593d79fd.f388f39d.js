"use strict";(self.webpackChunkahlek=self.webpackChunkahlek||[]).push([[5414],{8764:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>d,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>a});const o=JSON.parse('{"id":"tutorial-doc.md/linux-basic/moving-and-manipulating-files","title":"6. Moving and Manipulating Files","description":"6.1 Move the files and folders","source":"@site/docs/tutorial-doc.md/linux-basic/moving-and-manipulating-files.md","sourceDirName":"tutorial-doc.md/linux-basic","slug":"/tutorial-doc.md/linux-basic/moving-and-manipulating-files","permalink":"/lek/docs/tutorial-doc.md/linux-basic/moving-and-manipulating-files","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":6,"frontMatter":{"sidebar_position":6},"sidebar":"practicalSidebar","previous":{"title":"5. Creating Folders and Files","permalink":"/lek/docs/tutorial-doc.md/linux-basic/creating-folders-and-files"},"next":{"title":"7. A bit of Plumbing","permalink":"/lek/docs/tutorial-doc.md/linux-basic/a-bit-of-plumbing"}}');var i=n(4848),r=n(8453);const s={sidebar_position:6},d="6. Moving and Manipulating Files",l={},a=[{value:"6.1 Move the files and folders",id:"61-move-the-files-and-folders",level:2},{value:"6.2 Delete files and folders",id:"62-delete-files-and-folders",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",img:"img",p:"p",pre:"pre",strong:"strong",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"6-moving-and-manipulating-files",children:"6. Moving and Manipulating Files"})}),"\n",(0,i.jsx)(t.h2,{id:"61-move-the-files-and-folders",children:"6.1 Move the files and folders"}),"\n",(0,i.jsx)(t.p,{children:"Now that we\u2019ve got a few files, let\u2019s look at the sort of day-to-day tasks you might need to perform on them. In practice you\u2019ll still most likely use a graphical program when you want to move, rename or delete one or two files, but knowing how to do this using the command line can be useful for bulk changes, or when the files are spread amongst different folders. Plus, you\u2019ll learn a few more things about the command line along the way."}),"\n",(0,i.jsxs)(t.p,{children:["Let\u2019s begin by putting our ",(0,i.jsx)(t.strong,{children:"combined.txt"})," file into our ",(0,i.jsx)(t.strong,{children:"dir1"})," directory, using the ",(0,i.jsx)(t.code,{children:"mv"})," (move) command:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"mv combined.txt dir1\n"})}),"\n",(0,i.jsxs)(t.p,{children:["You can confirm that the job has been done by using ",(0,i.jsx)(t.code,{children:"ls"})," to see that it\u2019s missing from the working directory, then ",(0,i.jsx)(t.code,{children:"cd dir1"})," to change into ",(0,i.jsx)(t.strong,{children:"dir1"}),", ",(0,i.jsx)(t.code,{children:"ls"})," to see that it\u2019s in there, then ",(0,i.jsx)(t.code,{children:"cd .."})," to move the working directory back again. Or you could save a lot of typing by passing a path directly to the ",(0,i.jsx)(t.code,{children:"ls"})," command to get straight to the confirmation you\u2019re looking for:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"ls dir1\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Now suppose it turns out that file shouldn\u2019t be in ",(0,i.jsx)(t.strong,{children:"dir1"})," after all. Let\u2019s move it back to the working directory. We could ",(0,i.jsx)(t.code,{children:"cd"})," into ",(0,i.jsx)(t.strong,{children:"dir1"})," then use ",(0,i.jsx)(t.code,{children:"mv combined.txt .."})," to say \u201cmove combined.txt into the parent directory\u201d. But we can use another path shortcut to avoid changing directory at all. In the same way that two dots (",(0,i.jsx)(t.code,{children:".."}),") represents the parent directory, so a single dot (",(0,i.jsx)(t.code,{children:"."}),") can be used to represent the current working directory. Because we know there\u2019s only one file in ",(0,i.jsx)(t.strong,{children:"dir1"})," we can also just use \u201c",(0,i.jsx)(t.code,{children:"*"}),"\u201d to match any filename in that directory, saving ourselves a few more keystrokes. Our command to move the file back into the working directory therefore becomes this (note the space before the dot, there are two parameters being passed to ",(0,i.jsx)(t.code,{children:"mv"}),"):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"mv dir1/* .\n"})}),"\n",(0,i.jsxs)(t.p,{children:["The ",(0,i.jsx)(t.code,{children:"mv"})," command also lets us move more than one file at a time. If you pass more than two arguments, the last one is taken to be the destination directory and the others are considered to be files (or directories) to move. Let\u2019s use a single command to move ",(0,i.jsx)(t.strong,{children:"combined.txt"}),", all our ",(0,i.jsx)(t.strong,{children:"test_n.txt"})," files and ",(0,i.jsx)(t.strong,{children:"dir3"})," into ",(0,i.jsx)(t.strong,{children:"dir2"}),". There\u2019s a bit more going on here, but if you look at each argument at a time you should be able to work out what\u2019s happening:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"mv combined.txt test_* dir3 dir2\nls\nls dir2\n"})}),"\n",(0,i.jsxs)(t.p,{children:["With ",(0,i.jsx)(t.strong,{children:"combined.txt"})," now moved into ",(0,i.jsx)(t.strong,{children:"dir2"}),", what happens if we decide it\u2019s in the wrong place again? Instead of ",(0,i.jsx)(t.strong,{children:"dir2"})," it should have been put in ",(0,i.jsx)(t.strong,{children:"dir6"}),", which is the one that\u2019s inside ",(0,i.jsx)(t.strong,{children:"dir5"}),", which is in ",(0,i.jsx)(t.strong,{children:"dir4"}),". With what we now know about paths, that\u2019s no problem either:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"mv dir2/combined.txt dir4/dir5/dir6\nls dir2\nls dir4/dir5/dir6\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Notice how our ",(0,i.jsx)(t.code,{children:"mv"})," command let us move the file from one directory into another, even though our working directory is something completely different. This is a powerful property of the command line: no matter where in the file system you are, it\u2019s still possible to operate on files and folders in totally different locations."]}),"\n",(0,i.jsxs)(t.p,{children:["Since we seem to be using (and moving) that file a lot, perhaps we should keep a copy of it in our working directory. Much as the mv command moves files, so the ",(0,i.jsx)(t.code,{children:"cp"})," command copies them (again, note the space before the dot):"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"cp dir4/dir5/dir6/combined.txt .\nls dir4/dir5/dir6\nls\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Great! Now let\u2019s create another copy of the file, in our working directory but with a different name. We can use the ",(0,i.jsx)(t.code,{children:"cp"})," command again, but instead of giving it a directory path as the last argument, we\u2019ll give it a new file name instead:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"cp combined.txt backup_combined.txt\nls\n"})}),"\n",(0,i.jsxs)(t.p,{children:["That\u2019s good, but perhaps the choice of backup name could be better. Why not rename it so that it will always appear next to the original file in a sorted list. The traditional Unix command line handles a rename as though you\u2019re ",(0,i.jsx)(t.strong,{children:"moving"})," the file from one name to another, so our old friend ",(0,i.jsx)(t.code,{children:"mv"})," is the command to use. In this case you just specify two arguments: the file you want to rename, and the new name you wish to use."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"mv backup_combined.txt combined_backup.txt\nls\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This also works on directories, giving us a way to sort out those difficult ones with spaces in the name that we created earlier. To avoid re-typing each command after the first, use the ",(0,i.jsx)(t.strong,{children:"Up Arrow"})," to pull up the previous command in the history. You can then edit the command before you run it by moving the cursor left and right with the arrow keys, and removing the character to the left with ",(0,i.jsx)(t.strong,{children:"Backspace"})," or the one the cursor is on with ",(0,i.jsx)(t.strong,{children:"Delete"}),". Finally, type the new character in place, and press ",(0,i.jsx)(t.strong,{children:"Enter"})," or ",(0,i.jsx)(t.strong,{children:"Return"})," to run the command once you\u2019re finished. Make sure you change both appearances of the number in each of these lines."]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'mv "folder 1" folder_1\nmv "folder 2" folder_2\nmv "folder 3" folder_3\nmv "folder 4" folder_4\nmv "folder 5" folder_5\nmv "folder 6" folder_6\nls\n'})}),"\n",(0,i.jsx)(t.h2,{id:"62-delete-files-and-folders",children:"6.2 Delete files and folders"}),"\n",(0,i.jsxs)(t.p,{children:["Now we know how to move, copy and rename files and directories. Given that these are just test files, however, perhaps we don\u2019t really need three different copies of ",(0,i.jsx)(t.strong,{children:"combined.txt"})," after all. Let\u2019s tidy up a bit, using the ",(0,i.jsx)(t.code,{children:"rm"})," (remove) command:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"rm dir4/dir5/dir6/combined.txt combined_backup.txt\n"})}),"\n",(0,i.jsx)(t.p,{children:"Perhaps we should remove some of those excess directories as well:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"rm folder_*\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"alt text",src:n(9281).A+"",width:"780",height:"462"})}),"\n",(0,i.jsxs)(t.p,{children:["What happened there? Well, it turns out that rm does have one little safety net. Sure, you can use it to delete every single file in a directory with a single command, accidentally wiping out thousands of files in an instant, with no means to recover them. But it won\u2019t let you delete a directory. I suppose that does help prevent you accidentally deleting thousands more files, but it does seem a little petty for such a destructive command to balk at removing an empty directory. Luckily there\u2019s an ",(0,i.jsx)(t.code,{children:"rmdir"})," (remove directory) command that will do the job for us instead:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"rmdir folder_*\n"})}),"\n",(0,i.jsx)(t.p,{children:(0,i.jsx)(t.img,{alt:"alt text",src:n(4618).A+"",width:"555",height:"108"})}),"\n",(0,i.jsxs)(t.p,{children:["Well that\u2019s a little better, but there\u2019s still an error. If you run ",(0,i.jsx)(t.code,{children:"ls"})," you\u2019ll see that most of the folders have gone, but folder_6 is still hanging around. As you may recall, folder_6 still has a folder 7 inside it, and ",(0,i.jsx)(t.code,{children:"rmdir"})," will only delete empty folders. Again, it\u2019s a small safety net to prevent you from accidentally deleting a folder full of files when you didn\u2019t mean to."]}),"\n",(0,i.jsxs)(t.p,{children:["In this case, however, we do mean to. The addition of options to our ",(0,i.jsx)(t.code,{children:"rm"})," or ",(0,i.jsx)(t.code,{children:"rmdir"})," commands will let us perform dangerous actions without the aid of a safety net! In the case of rmdir we can add a ",(0,i.jsx)(t.code,{children:"-p"})," switch to tell it to also remove the parent directories. Think of it as the counterpoint to ",(0,i.jsx)(t.code,{children:"mkdir -p"}),". So if you were to run rmdir -p dir1/dir2/dir3 it would first delete dir3, then dir2, then finally delete dir1. It still follows the normal ",(0,i.jsx)(t.code,{children:"rmdir"})," rules of only deleting empty directories though, so if there was also a file in dir1, for example, only dir3 and dir2 would get removed."]}),"\n",(0,i.jsxs)(t.p,{children:["A more common approach, when you\u2019re really, really, really sure you want to delete a whole directory and anything within it, is to tell ",(0,i.jsx)(t.code,{children:"rm"})," to work recursively by using the ",(0,i.jsx)(t.code,{children:"-r"})," switch, in which case it will happily delete folders as well as files. With that in mind, here\u2019s the command to get rid of that pesky folder_6 and the subdirectory within it:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"rm -r folder_6\nls\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Remember: although ",(0,i.jsx)(t.code,{children:"rm -r"})," is quick and convenient, it\u2019s also dangerous. It\u2019s safest to explicitly delete files to clear out a directory, then ",(0,i.jsx)(t.code,{children:"cd .."})," to the parent before using rmdir to remove it."]})]})}function h(e={}){const{wrapper:t}={...(0,r.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},9281:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/image-5-39b4f2df7b7b4eceddd402a040aaf728.png"},4618:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/image-6-1559cf62826c548f0838e9e80838e119.png"},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>d});var o=n(6540);const i={},r=o.createContext(i);function s(e){const t=o.useContext(r);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function d(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),o.createElement(r.Provider,{value:t},e.children)}}}]);