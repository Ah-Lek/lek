"use strict";(self.webpackChunkahlek=self.webpackChunkahlek||[]).push([[7721],{2300:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>h,frontMatter:()=>a,metadata:()=>o,toc:()=>l});const o=JSON.parse('{"id":"tutorial-doc.md/linux-basic/creating-folders-and-files","title":"5. Creating Folders and Files","description":"5.1 Create Folder","source":"@site/docs/tutorial-doc.md/linux-basic/creating-folders-and-files.md","sourceDirName":"tutorial-doc.md/linux-basic","slug":"/tutorial-doc.md/linux-basic/creating-folders-and-files","permalink":"/lek/docs/tutorial-doc.md/linux-basic/creating-folders-and-files","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"practicalSidebar","previous":{"title":"4. Open a Terminal","permalink":"/lek/docs/tutorial-doc.md/linux-basic/open-a-terminal"},"next":{"title":"6. Moving and Manipulating Files","permalink":"/lek/docs/tutorial-doc.md/linux-basic/moving-and-manipulating-files"}}');var r=n(4848),i=n(8453);const a={sidebar_position:5},s="5. Creating Folders and Files",d={},l=[{value:"5.1 Create Folder",id:"51-create-folder",level:2},{value:"5.2 Create files using redirection",id:"52-create-files-using-redirection",level:2},{value:"5.3 A note about case",id:"53-a-note-about-case",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",header:"header",img:"img",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"5-creating-folders-and-files",children:"5. Creating Folders and Files"})}),"\n",(0,r.jsx)(t.h2,{id:"51-create-folder",children:"5.1 Create Folder"}),"\n",(0,r.jsx)(t.p,{children:"In this section we\u2019re going to create some real files to work with. To avoid accidentally trampling over any of your real files, we\u2019re going to start by creating a new directory, well away from your home folder, which will serve as a safer environment in which to experiment:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-mkdir",metastring:"/tmp/tutorial",children:"cd /tmp/tutorial\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Notice the use of an absolute path, to make sure that we create the ",(0,r.jsx)(t.strong,{children:"tutorial"})," directory inside ",(0,r.jsx)(t.strong,{children:"/tmp"}),". Without the forward slash at the start the ",(0,r.jsx)(t.code,{children:"mkdir"})," command would try to find a tmp directory inside the current working directory, then try to create a tutorial directory inside that. If it couldn\u2019t find a tmp directory the command would fail."]}),"\n",(0,r.jsx)(t.p,{children:"In case you hadn\u2019t guessed, mkdir is short for \u2018make directory\u2019. Now that we\u2019re safely inside our test area (double check with pwd if you\u2019re not certain), let\u2019s create a few subdirectories:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"mkdir dir1 dir2 dir3\n"})}),"\n",(0,r.jsxs)(t.p,{children:["There\u2019s something a little different about that command. So far we\u2019ve only seen commands that work on their own (cd, pwd) or that have a single item afterwards (cd /, cd ~/Desktop). But this time we\u2019ve added three things after the mkdir command. Those things are referred to as ",(0,r.jsx)(t.strong,{children:"parameters"})," or ",(0,r.jsx)(t.strong,{children:"arguments"})," and different commands can accept different numbers of arguments. The mkdir command expects at least one argument, whereas the cd command can work with zero or one, but no more. See what happens when you try to pass the wrong number of parameters to a command:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"mkdir\ncd /etc ~/Desktop\n"})}),"\n",(0,r.jsxs)(t.p,{children:["Back to our new directories. The command above will have created three new subdirectories inside our folder. Let\u2019s take a look at them with the ",(0,r.jsx)(t.code,{children:"ls"})," (list) command:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"ls\n"})}),"\n",(0,r.jsx)(t.p,{children:"If you\u2019ve followed the last few commands, your terminal should be looking something like this:"}),"\n",(0,r.jsx)(t.p,{children:"The terminal, after running mkdir and ls"}),"\n",(0,r.jsx)(t.p,{children:(0,r.jsx)(t.img,{alt:"alt text",src:n(9336).A+"",width:"549",height:"321"})}),"\n",(0,r.jsxs)(t.p,{children:["Notice that mkdir created all the folders in one directory. It ",(0,r.jsx)(t.strong,{children:"didn\u2019t"})," create dir3 inside dir2 inside dir1, or any other nested structure. But sometimes it\u2019s handy to be able to do exactly that, and mkdir does have a way:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"mkdir -p dir4/dir5/dir6\nls\n"})}),"\n",(0,r.jsx)(t.p,{children:"This time you\u2019ll see that only dir4 has been added to the list, because dir5 is inside it, and dir6 is inside that. Later we\u2019ll install a useful tool to visualise the structure, but you\u2019ve already got enough knowledge to confirm it:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"cd dir4\nls\ncd dir5\nls\ncd ../..\n"})}),"\n",(0,r.jsx)(t.p,{children:"The \u201c-p\u201d that we used is called an option or a switch (in this case it means \u201ccreate the parent directories, too\u201d). Options are used to modify the way in which a command operates, allowing a single command to behave in a variety of different ways. Unfortunately, due to quirks of history and human nature, options can take different forms in different commands. You\u2019ll often see them as single characters preceded by a hyphen (as in this case), or as longer words preceded by two hyphens. The single character form allows for multiple options to be combined, though not all commands will accept that. And to confuse matters further, some commands don\u2019t clearly identify their options at all, whether or not something is an option is dictated purely by the order of the arguments! You don\u2019t need to worry about all the possibilities, just know that options exist and they can take several different forms. For example the following all mean exactly the same thing:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"# Don't type these in, they're just here for demonstrative purposes\nmkdir --parents --verbose dir4/dir5\nmkdir -p --verbose dir4/dir5\nmkdir -p -v dir4/dir5\nmkdir -pv dir4/dir5\n"})}),"\n",(0,r.jsx)(t.p,{children:"Now we know how to create multiple directories just by passing them as separare arguments to the mkdir command. But suppose we want to create a directory with a space in the name? Let\u2019s give it a go:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"mkdir another folder\nls\n"})}),"\n",(0,r.jsx)(t.p,{children:"You probably didn\u2019t even need to type that one in to guess what would happen: two new folders, one called another and the other called folder. If you want to work with spaces in directory or file names, you need to escape them. Don\u2019t worry, nobody\u2019s breaking out of prison; escaping is a computing term that refers to using special codes to tell the computer to treat particular characters differently to normal. Enter the following commands to try out different ways to create folders with spaces in the name:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'mkdir "folder 1"\nmkdir \'folder 2\'\nmkdir folder\\ 3\nmkdir "folder 4" "folder 5"\nmkdir -p "folder 6"/"folder 7"\nls\n'})}),"\n",(0,r.jsx)(t.p,{children:"Although the command line can be used to work with files and folders with spaces in their names, the need to escape them with quote marks or backslashes makes things a little more difficult. You can often tell a person who uses the command line a lot just from their file names: they\u2019ll tend to stick to letters and numbers, and use underscores (\u201c_\u201d) or hyphens (\u201c-\u201d) instead of spaces."}),"\n",(0,r.jsx)(t.h2,{id:"52-create-files-using-redirection",children:"5.2 Create files using redirection"}),"\n",(0,r.jsx)(t.p,{children:"Our demonstration folder is starting to look rather full of directories, but is somewhat lacking in files. Let\u2019s remedy that by redirecting the output from a command so that, instead of being printed to the screen, it ends up in a new file. First, remind yourself what the ls command is currently showing:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"ls\n"})}),"\n",(0,r.jsx)(t.p,{children:"Suppose we wanted to capture the output of that command as a text file that we can look at or manipulate further. All we need to do is to add the greater-than character (\u201c>\u201d) to the end of our command line, followed by the name of the file to write to:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"ls > output.txt\n"})}),"\n",(0,r.jsx)(t.p,{children:"This time there\u2019s nothing printed to the screen, because the output is being redirected to our file instead. If you just run ls on its own you should see that the output.txt file has been created. We can use the cat command to look at its content:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"cat output.txt\n"})}),"\n",(0,r.jsx)(t.p,{children:"Okay, so it\u2019s not exactly what was displayed on the screen previously, but it contains all the same data, and it\u2019s in a more useful format for further processing. Let\u2019s look at another command, echo:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'echo "This is a test"\n'})}),"\n",(0,r.jsx)(t.p,{children:"Yes, echo just prints its arguments back out again (hence the name). But combine it with a redirect, and you\u2019ve got a way to easily create small test files:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'echo "This is a test" > test_1.txt\necho "This is a second test" > test_2.txt\necho "This is a third test" > test_3.txt\nls\n'})}),"\n",(0,r.jsx)(t.p,{children:"You should cat each of these files to check their contents. But cat is more than just a file viewer - its name comes from \u2018concatenate\u2019, meaning \u201cto link together\u201d. If you pass more than one filename to cat it will output each of them, one after the other, as a single block of text:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"cat test_1.txt test_2.txt test_3.txt\n"})}),"\n",(0,r.jsx)(t.p,{children:"Where you want to pass multiple file names to a single command, there are some useful shortcuts that can save you a lot of typing if the files have similar names. A question mark (\u201c?\u201d) can be used to indicate \u201cany single character\u201d within the file name. An asterisk (\u201c*\u201d) can be used to indicate \u201czero or more characters\u201d. These are sometimes referred to as \u201cwildcard\u201d characters. A couple of examples might help, the following commands all do the same thing:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"cat test_1.txt test_2.txt test_3.txt\ncat test_?.txt\ncat test_*\n"})}),"\n",(0,r.jsx)(t.p,{children:"If you look at the output of ls you\u2019ll notice that the only files or folders that start with \u201ct\u201d are the three test files we\u2019ve just created, so you could even simplify that last command even further to cat t*, meaning \u201cconcatenate all the files whose names start with a t and are followed by zero or more other characters\u201d. Let\u2019s use this capability to join all our files together into a single new file, then view it:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"cat t* > combined.txt\ncat combined.txt\n"})}),"\n",(0,r.jsx)(t.p,{children:"What do you think will happen if we run those two commands a second time? Will the computer complain, because the file already exists? Will it append the text to the file, so it contains two copies? Or will it replace it entirely? Give it a try to see what happens, but to avoid typing the commands again you can use the Up Arrow and Down Arrow keys to move back and forth through the history of commands you\u2019ve used. Press the Up Arrow a couple of times to get to the first cat and press Enter to run it, then do the same again to get to the second."}),"\n",(0,r.jsx)(t.p,{children:"As you can see, the file looks the same. That\u2019s not because it\u2019s been left untouched, but because the shell clears out all the content of the file before it writes the output of your cat command into it. Because of this, you should be extra careful when using redirection to make sure that you don\u2019t accidentally overwrite a file you need. If you do want to append to, rather than replace, the content of the files, double up on the greater-than character:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'cat t* >> combined.txt\necho "I\'ve appended a line!" >> combined.txt\ncat combined.txt\n'})}),"\n",(0,r.jsxs)(t.p,{children:["Repeat the first cat a few more times, using the ",(0,r.jsx)(t.strong,{children:"Up Arrow"})," for convenience, and perhaps add a few more arbitrary echo commands, until your text document is so large that it won\u2019t all fit in the terminal at once when you use cat to display it. In order to see the whole file we now need to use a different program, called a pager (because it displays your file one \u201cpage\u201d at a time). The standard pager of old was called more, because it puts a line of text at the bottom of each page that says \u201c\u2013More\u2013\u201d to indicate that you haven\u2019t read everything yet. These days there\u2019s a far better pager that you should use instead: because it replaces more, the programmers decided to call it less."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:"less combined.txt\n"})}),"\n",(0,r.jsxs)(t.p,{children:["When viewing a file through less you can use the ",(0,r.jsx)(t.strong,{children:"Up Arrow, Down Arrow, Page Up, Page Down, Home and End"})," keys to move through your file. Give them a try to see the difference between them. When you\u2019ve finished viewing your file, press q to quit less and return to the command line."]}),"\n",(0,r.jsx)(t.h2,{id:"53-a-note-about-case",children:"5.3 A note about case"}),"\n",(0,r.jsx)(t.p,{children:"Unix systems are case-sensitive, that is, they consider \u201cA.txt\u201d and \u201ca.txt\u201d to be two different files. If you were to run the following lines you would end up with three files:"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{children:'echo "Lower case" > a.txt\necho "Upper case" > A.TXT\necho "Mixed case" > A.txt\n'})}),"\n",(0,r.jsx)(t.p,{children:"Generally you should try to avoid creating files and folders whose name only varies by case. Not only will it help to avoid confusion, but it will also prevent problems when working with different operating systems. Windows, for example, is case-insensitive, so it would treat all three of the file names above as being a single file, potentially causing data loss or other problems."}),"\n",(0,r.jsxs)(t.p,{children:["You might be tempted to just hit the ",(0,r.jsx)(t.strong,{children:"Caps Lock"})," key and use upper case for all your file names. But the vast majority of shell commands are lower case, so you would end up frequently having to turn it on and off as you type. Most seasoned command line users tend to stick primarily to lower case names for their files and directories so that they rarely have to worry about file name clashes, or which case to use for each letter in the name."]})]})}function h(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},9336:(e,t,n)=>{n.d(t,{A:()=>o});const o=n.p+"assets/images/image-4-1fc8b795cf7d175e468a3a96aa1a9625.png"},8453:(e,t,n)=>{n.d(t,{R:()=>a,x:()=>s});var o=n(6540);const r={},i=o.createContext(r);function a(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:a(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);